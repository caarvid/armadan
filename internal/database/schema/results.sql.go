// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: results.sql

package schema

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createResult = `-- name: CreateResult :one
INSERT INTO results (week_id) VALUES ($1) RETURNING id, week_id, published
`

func (q *Queries) CreateResult(ctx context.Context, weekID uuid.UUID) (Result, error) {
	row := q.db.QueryRow(ctx, createResult, weekID)
	var i Result
	err := row.Scan(&i.ID, &i.WeekID, &i.Published)
	return i, err
}

const createRound = `-- name: CreateRound :one
INSERT INTO rounds (player_id, result_id, net_in, net_out, gross_in, gross_out, new_hcp, old_hcp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, net_in, net_out, gross_in, gross_out, old_hcp, new_hcp, player_id, result_id
`

type CreateRoundParams struct {
	PlayerID uuid.UUID       `json:"playerId"`
	ResultID uuid.UUID       `json:"resultId"`
	NetIn    int32           `json:"netIn"`
	NetOut   int32           `json:"netOut"`
	GrossIn  int32           `json:"grossIn"`
	GrossOut int32           `json:"grossOut"`
	NewHcp   decimal.Decimal `json:"newHcp"`
	OldHcp   decimal.Decimal `json:"oldHcp"`
}

func (q *Queries) CreateRound(ctx context.Context, arg *CreateRoundParams) (Round, error) {
	row := q.db.QueryRow(ctx, createRound,
		arg.PlayerID,
		arg.ResultID,
		arg.NetIn,
		arg.NetOut,
		arg.GrossIn,
		arg.GrossOut,
		arg.NewHcp,
		arg.OldHcp,
	)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.NetIn,
		&i.NetOut,
		&i.GrossIn,
		&i.GrossOut,
		&i.OldHcp,
		&i.NewHcp,
		&i.PlayerID,
		&i.ResultID,
	)
	return i, err
}

type CreateScoresParams struct {
	RoundID uuid.UUID `json:"roundId"`
	HoleID  uuid.UUID `json:"holeId"`
	Strokes int32     `json:"strokes"`
}

const deleteResult = `-- name: DeleteResult :exec
DELETE FROM results WHERE id = $1
`

func (q *Queries) DeleteResult(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteResult, id)
	return err
}

const deleteRound = `-- name: DeleteRound :exec
DELETE FROM rounds WHERE id = $1
`

func (q *Queries) DeleteRound(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRound, id)
	return err
}

const getLeaderboardSummary = `-- name: GetLeaderboardSummary :many
WITH winner_data AS (
  SELECT w.id, w.points, w.player_id, w.result_id FROM winners w
), result_data AS (
  SELECT r.id, r.week_id, r.published FROM results r
)
SELECT wk.id, wk.nr, COALESCE(wd.points, 0) AS points, COALESCE(rd.published, false) as has_results FROM weeks wk
LEFT JOIN result_data rd ON rd.week_id = wk.id 
LEFT JOIN winner_data wd ON rd.id = wd.result_id AND wd.player_id = $1::UUID 
GROUP BY wk.id, wd.points, rd.published
ORDER BY wk.nr ASC
`

type GetLeaderboardSummaryRow struct {
	ID         uuid.UUID `json:"id"`
	Nr         int32     `json:"nr"`
	Points     int32     `json:"points"`
	HasResults bool      `json:"hasResults"`
}

func (q *Queries) GetLeaderboardSummary(ctx context.Context, dollar_1 uuid.UUID) ([]GetLeaderboardSummaryRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardSummary, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardSummaryRow
	for rows.Next() {
		var i GetLeaderboardSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.Nr,
			&i.Points,
			&i.HasResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManageResultView = `-- name: GetManageResultView :many
WITH result_data AS (
  SELECT r.id, r.published, r.week_id 
  FROM results r
), participant_counts AS (
  SELECT r.result_id, COUNT(r.id) AS participants
  FROM rounds r
  GROUP BY r.result_id
), winner_counts AS (
  SELECT w.result_id, COUNT(w.id) AS winners
  FROM winners w
  GROUP BY w.result_id
)
SELECT 
  wd.id,
  wd.nr,
  wd.is_finals,
  wd.course_name,
  wd.tee_name,
  rd.id::UUID AS result_id,
  COALESCE(rd.published, false) AS published,
  COALESCE(pc.participants, 0) AS participants,
  COALESCE(wc.winners, 0) AS winners
FROM week_details wd
LEFT JOIN result_data rd ON rd.week_id = wd.id
LEFT JOIN participant_counts pc ON pc.result_id = rd.id
LEFT JOIN winner_counts wc ON wc.result_id = rd.id
ORDER BY wd.nr ASC
`

type GetManageResultViewRow struct {
	ID           uuid.UUID   `json:"id"`
	Nr           int32       `json:"nr"`
	IsFinals     pgtype.Bool `json:"isFinals"`
	CourseName   string      `json:"courseName"`
	TeeName      string      `json:"teeName"`
	ResultID     uuid.UUID   `json:"resultId"`
	Published    bool        `json:"published"`
	Participants int64       `json:"participants"`
	Winners      int64       `json:"winners"`
}

func (q *Queries) GetManageResultView(ctx context.Context) ([]GetManageResultViewRow, error) {
	rows, err := q.db.Query(ctx, getManageResultView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManageResultViewRow
	for rows.Next() {
		var i GetManageResultViewRow
		if err := rows.Scan(
			&i.ID,
			&i.Nr,
			&i.IsFinals,
			&i.CourseName,
			&i.TeeName,
			&i.ResultID,
			&i.Published,
			&i.Participants,
			&i.Winners,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRemainingPlayersByResultId = `-- name: GetRemainingPlayersByResultId :many
SELECT p.id, p.first_name, p.last_name, p.points, p.user_id, p.hcp
FROM players p
LEFT JOIN rounds r 
  ON r.player_id = p.id 
  AND r.result_id = $1
WHERE r.player_id IS NULL
ORDER BY p.last_name ASC, p.first_name ASC
`

func (q *Queries) GetRemainingPlayersByResultId(ctx context.Context, resultID uuid.UUID) ([]Player, error) {
	rows, err := q.db.Query(ctx, getRemainingPlayersByResultId, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Player
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Points,
			&i.UserID,
			&i.Hcp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResultById = `-- name: GetResultById :one
WITH week_data AS (
  SELECT w.id, w.nr, w.course_id, w.tee_id FROM weeks w
), tee_data AS (
  SELECT t.id, t.slope, t.cr FROM tees t
)
SELECT
  r.id,
  td.slope,
  td.cr,
  wd.nr::integer as week_nr,
  wd.course_id::UUID as course_id
FROM results r
LEFT JOIN week_data wd ON wd.id = r.week_id
LEFT JOIN tee_data td ON td.id = wd.tee_id
WHERE r.id = $1
`

type GetResultByIdRow struct {
	ID       uuid.UUID      `json:"id"`
	Slope    pgtype.Int4    `json:"slope"`
	Cr       pgtype.Numeric `json:"cr"`
	WeekNr   int32          `json:"weekNr"`
	CourseID uuid.UUID      `json:"courseId"`
}

func (q *Queries) GetResultById(ctx context.Context, id uuid.UUID) (GetResultByIdRow, error) {
	row := q.db.QueryRow(ctx, getResultById, id)
	var i GetResultByIdRow
	err := row.Scan(
		&i.ID,
		&i.Slope,
		&i.Cr,
		&i.WeekNr,
		&i.CourseID,
	)
	return i, err
}

const getRoundsByResultId = `-- name: GetRoundsByResultId :many
WITH player_data AS (
  SELECT p.id, p.first_name, p.last_name, p.hcp FROM players p
)
SELECT 
  r.id, r.net_in, r.net_out, r.gross_in, r.gross_out, r.old_hcp, r.new_hcp, r.player_id, r.result_id, 
  r.net_in + r.net_out AS net_total,
  r.gross_in + r.gross_out AS gross_total,
  p.first_name, 
  p.last_name, 
  p.hcp
FROM rounds r
LEFT JOIN player_data p ON p.id = r.player_id
WHERE r.result_id = $1
ORDER BY net_total ASC
`

type GetRoundsByResultIdRow struct {
	ID         uuid.UUID       `json:"id"`
	NetIn      int32           `json:"netIn"`
	NetOut     int32           `json:"netOut"`
	GrossIn    int32           `json:"grossIn"`
	GrossOut   int32           `json:"grossOut"`
	OldHcp     decimal.Decimal `json:"oldHcp"`
	NewHcp     decimal.Decimal `json:"newHcp"`
	PlayerID   uuid.UUID       `json:"playerId"`
	ResultID   uuid.UUID       `json:"resultId"`
	NetTotal   int32           `json:"netTotal"`
	GrossTotal int32           `json:"grossTotal"`
	FirstName  string          `json:"firstName"`
	LastName   string          `json:"lastName"`
	Hcp        pgtype.Numeric  `json:"hcp"`
}

func (q *Queries) GetRoundsByResultId(ctx context.Context, resultID uuid.UUID) ([]GetRoundsByResultIdRow, error) {
	rows, err := q.db.Query(ctx, getRoundsByResultId, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundsByResultIdRow
	for rows.Next() {
		var i GetRoundsByResultIdRow
		if err := rows.Scan(
			&i.ID,
			&i.NetIn,
			&i.NetOut,
			&i.GrossIn,
			&i.GrossOut,
			&i.OldHcp,
			&i.NewHcp,
			&i.PlayerID,
			&i.ResultID,
			&i.NetTotal,
			&i.GrossTotal,
			&i.FirstName,
			&i.LastName,
			&i.Hcp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
