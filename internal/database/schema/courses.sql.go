// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: courses.sql

package schema

import (
	"context"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createCourse = `-- name: CreateCourse :one
INSERT INTO courses (name, par) VALUES ($1, $2) RETURNING id, name, par
`

type CreateCourseParams struct {
	Name string `json:"name"`
	Par  int32  `json:"par"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg *CreateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, createCourse, arg.Name, arg.Par)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.Par)
	return i, err
}

type CreateHolesParams struct {
	Nr       int32     `json:"nr"`
	Par      int32     `json:"par"`
	Index    int32     `json:"index"`
	CourseID uuid.UUID `json:"courseId"`
}

type CreateTeesParams struct {
	Name     string          `json:"name"`
	Slope    int32           `json:"slope"`
	Cr       decimal.Decimal `json:"cr"`
	CourseID uuid.UUID       `json:"courseId"`
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses WHERE id = $1
`

func (q *Queries) DeleteCourse(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCourse, id)
	return err
}

const deleteTee = `-- name: DeleteTee :exec
DELETE FROM tees WHERE id = $1
`

func (q *Queries) DeleteTee(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTee, id)
	return err
}

const getCourse = `-- name: GetCourse :one
SELECT
  c.id,
  c.name,
  c.par,
  COALESCE(
    (
      SELECT jsonb_agg(to_jsonb(t))
      FROM tees t 
      WHERE t.course_id = c.id
    ), '[]'
  )::jsonb AS tees,
  COALESCE(
    (
      SELECT jsonb_agg(to_jsonb(h) ORDER BY h.nr)
      FROM holes h 
      WHERE h.course_id = c.id
  ), '[]'
  )::jsonb AS holes
FROM courses c
WHERE c.id=$1
`

type GetCourseRow struct {
	ID    uuid.UUID `json:"id"`
	Name  string    `json:"name"`
	Par   int32     `json:"par"`
	Tees  []byte    `json:"tees"`
	Holes []byte    `json:"holes"`
}

func (q *Queries) GetCourse(ctx context.Context, id uuid.UUID) (GetCourseRow, error) {
	row := q.db.QueryRow(ctx, getCourse, id)
	var i GetCourseRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Par,
		&i.Tees,
		&i.Holes,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :many
SELECT
  c.id,
  c.name,
  c.par,
  COALESCE(
    (
      SELECT jsonb_agg(to_jsonb(t))
      FROM tees t 
      WHERE t.course_id = c.id
    ), '[]'
  )::jsonb AS tees,
  COALESCE(
    (
      SELECT jsonb_agg(to_jsonb(h) ORDER BY h.nr)
      FROM holes h 
      WHERE h.course_id = c.id
  ), '[]'
  )::jsonb AS holes
FROM courses c
GROUP BY c.id
`

type GetCoursesRow struct {
	ID    uuid.UUID `json:"id"`
	Name  string    `json:"name"`
	Par   int32     `json:"par"`
	Tees  []byte    `json:"tees"`
	Holes []byte    `json:"holes"`
}

func (q *Queries) GetCourses(ctx context.Context) ([]GetCoursesRow, error) {
	rows, err := q.db.Query(ctx, getCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesRow
	for rows.Next() {
		var i GetCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Par,
			&i.Tees,
			&i.Holes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCourse = `-- name: UpdateCourse :one
UPDATE courses SET name = $1, par = $2 WHERE id = $3 RETURNING id, name, par
`

type UpdateCourseParams struct {
	Name string    `json:"name"`
	Par  int32     `json:"par"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg *UpdateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, updateCourse, arg.Name, arg.Par, arg.ID)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.Par)
	return i, err
}
