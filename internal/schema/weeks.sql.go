// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: weeks.sql

package schema

import (
	"context"

	"github.com/caarvid/armadan/internal/dto"
	"github.com/google/uuid"
)

const createWeek = `-- name: CreateWeek :one
INSERT INTO weeks (nr, course_id, tee_id) VALUES ($1, $2, $3) RETURNING id, nr, course_id, tee_id
`

type CreateWeekParams struct {
	Nr       int32     `json:"nr"`
	CourseID uuid.UUID `json:"courseId"`
	TeeID    uuid.UUID `json:"teeId"`
}

func (q *Queries) CreateWeek(ctx context.Context, arg *CreateWeekParams) (Week, error) {
	row := q.db.QueryRow(ctx, createWeek, arg.Nr, arg.CourseID, arg.TeeID)
	var i Week
	err := row.Scan(
		&i.ID,
		&i.Nr,
		&i.CourseID,
		&i.TeeID,
	)
	return i, err
}

const deleteWeek = `-- name: DeleteWeek :exec
DELETE FROM weeks WHERE id = $1
`

func (q *Queries) DeleteWeek(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWeek, id)
	return err
}

const getWeek = `-- name: GetWeek :one
WITH week_course_data AS (
	SELECT
		w.id,
		w.nr,
		jsonb_build_object(
			'id', c.id,
			'name', c.name
		) AS course
	FROM weeks w
	LEFT JOIN courses c ON c.id = w.course_id
	GROUP BY w.id, w.nr, c.id, c.name
), week_tee_data AS (
	SELECT
		w.id,
		jsonb_build_object(
			'id', t.id,
			'name', t.name
		) AS tee
	FROM weeks w
	LEFT JOIN tees t ON t.id = w.tee_id
	GROUP BY w.id, t.id, t.name
)
SELECT cd.id, cd.nr, cd.course, td.tee FROM week_course_data cd JOIN week_tee_data td USING (id) WHERE id = $1::UUID
`

type GetWeekRow struct {
	ID     uuid.UUID       `json:"id"`
	Nr     int32           `json:"nr"`
	Course *dto.WeekCourse `json:"course"`
	Tee    *dto.WeekTee    `json:"tee"`
}

func (q *Queries) GetWeek(ctx context.Context, dollar_1 uuid.UUID) (GetWeekRow, error) {
	row := q.db.QueryRow(ctx, getWeek, dollar_1)
	var i GetWeekRow
	err := row.Scan(
		&i.ID,
		&i.Nr,
		&i.Course,
		&i.Tee,
	)
	return i, err
}

const getWeeks = `-- name: GetWeeks :many
WITH week_course_data AS (
	SELECT
		w.id,
		w.nr,
		jsonb_build_object(
			'id', c.id,
			'name', c.name
		) AS course
	FROM weeks w
	LEFT JOIN courses c ON c.id = w.course_id
	GROUP BY w.id, w.nr, c.id, c.name
), week_tee_data AS (
	SELECT
		w.id,
		jsonb_build_object(
			'id', t.id,
			'name', t.name
		) AS tee
	FROM weeks w
	LEFT JOIN tees t ON t.id = w.tee_id
	GROUP BY w.id, t.id, t.name
)
SELECT cd.id, cd.nr, cd.course, td.tee FROM week_course_data cd JOIN week_tee_data td USING (id) ORDER BY nr ASC
`

type GetWeeksRow struct {
	ID     uuid.UUID       `json:"id"`
	Nr     int32           `json:"nr"`
	Course *dto.WeekCourse `json:"course"`
	Tee    *dto.WeekTee    `json:"tee"`
}

func (q *Queries) GetWeeks(ctx context.Context) ([]GetWeeksRow, error) {
	rows, err := q.db.Query(ctx, getWeeks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeksRow
	for rows.Next() {
		var i GetWeeksRow
		if err := rows.Scan(
			&i.ID,
			&i.Nr,
			&i.Course,
			&i.Tee,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWeek = `-- name: UpdateWeek :one
UPDATE weeks SET nr = $1, course_id = $2, tee_id = $3 WHERE id = $4 RETURNING id, nr, course_id, tee_id
`

type UpdateWeekParams struct {
	Nr       int32     `json:"nr"`
	CourseID uuid.UUID `json:"courseId"`
	TeeID    uuid.UUID `json:"teeId"`
	ID       uuid.UUID `json:"id"`
}

func (q *Queries) UpdateWeek(ctx context.Context, arg *UpdateWeekParams) (Week, error) {
	row := q.db.QueryRow(ctx, updateWeek,
		arg.Nr,
		arg.CourseID,
		arg.TeeID,
		arg.ID,
	)
	var i Week
	err := row.Scan(
		&i.ID,
		&i.Nr,
		&i.CourseID,
		&i.TeeID,
	)
	return i, err
}
