// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: results.sql

package schema

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createResult = `-- name: CreateResult :one
INSERT INTO results (week_id) VALUES ($1) RETURNING id, week_id, published
`

func (q *Queries) CreateResult(ctx context.Context, weekID uuid.UUID) (Result, error) {
	row := q.db.QueryRow(ctx, createResult, weekID)
	var i Result
	err := row.Scan(&i.ID, &i.WeekID, &i.Published)
	return i, err
}

const createRound = `-- name: CreateRound :one
INSERT INTO rounds (player_id, result_id, net_in, net_out, gross_in, gross_out, new_hcp, old_hcp) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING id, net_in, net_out, gross_in, gross_out, old_hcp, new_hcp, player_id, result_id
`

type CreateRoundParams struct {
	PlayerID uuid.UUID       `json:"playerId"`
	ResultID uuid.UUID       `json:"resultId"`
	NetIn    int32           `json:"netIn"`
	NetOut   int32           `json:"netOut"`
	GrossIn  int32           `json:"grossIn"`
	GrossOut int32           `json:"grossOut"`
	NewHcp   decimal.Decimal `json:"newHcp"`
	OldHcp   decimal.Decimal `json:"oldHcp"`
}

func (q *Queries) CreateRound(ctx context.Context, arg *CreateRoundParams) (Round, error) {
	row := q.db.QueryRow(ctx, createRound,
		arg.PlayerID,
		arg.ResultID,
		arg.NetIn,
		arg.NetOut,
		arg.GrossIn,
		arg.GrossOut,
		arg.NewHcp,
		arg.OldHcp,
	)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.NetIn,
		&i.NetOut,
		&i.GrossIn,
		&i.GrossOut,
		&i.OldHcp,
		&i.NewHcp,
		&i.PlayerID,
		&i.ResultID,
	)
	return i, err
}

type CreateScoresParams struct {
	RoundID uuid.UUID `json:"roundId"`
	HoleID  uuid.UUID `json:"holeId"`
	Strokes int32     `json:"strokes"`
}

const deleteResult = `-- name: DeleteResult :exec
DELETE FROM results WHERE id = $1
`

func (q *Queries) DeleteResult(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteResult, id)
	return err
}

const deleteRound = `-- name: DeleteRound :exec
DELETE FROM rounds WHERE id = $1
`

func (q *Queries) DeleteRound(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRound, id)
	return err
}

const getLeaderboardSummary = `-- name: GetLeaderboardSummary :many
WITH winner_data AS (
  SELECT w.id, w.points, w.player_id, w.result_id FROM winners w
), result_data AS (
  SELECT r.id, r.week_id, r.published FROM results r
)
SELECT wk.id, wk.nr, COALESCE(wd.points, 0) AS points, COALESCE(rd.published, false) as has_results FROM weeks wk
LEFT JOIN result_data rd ON rd.week_id = wk.id 
LEFT JOIN winner_data wd ON rd.id = wd.result_id AND wd.player_id = $1::UUID 
GROUP BY wk.id, wd.points, rd.published
ORDER BY wk.nr ASC
`

type GetLeaderboardSummaryRow struct {
	ID         uuid.UUID `json:"id"`
	Nr         int32     `json:"nr"`
	Points     int32     `json:"points"`
	HasResults bool      `json:"hasResults"`
}

func (q *Queries) GetLeaderboardSummary(ctx context.Context, dollar_1 uuid.UUID) ([]GetLeaderboardSummaryRow, error) {
	rows, err := q.db.Query(ctx, getLeaderboardSummary, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaderboardSummaryRow
	for rows.Next() {
		var i GetLeaderboardSummaryRow
		if err := rows.Scan(
			&i.ID,
			&i.Nr,
			&i.Points,
			&i.HasResults,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getManageResultView = `-- name: GetManageResultView :many
WITH result_data AS (
  SELECT r.id, r.published, r.week_id FROM results r
), course_data AS (
  SELECT c.id, c.name FROM courses c
), round_data AS (
  SELECT r.id, r.result_id FROM rounds r
), winner_data AS (
  SELECT w.id, w.result_id FROM winners w
), tee_data AS (
  SELECT t.id, t.name FROM tees t
)
  SELECT 
    w.id,
    w.nr,
    w.is_finals,
    cd.name AS course_name,
    td.name AS tee_name,
    rd.id::UUID AS result_id,
    COALESCE(rd.published, false) AS published,
    COUNT(r.id) AS participants,
    COUNT(wd.id) AS winners,
    CASE 
        WHEN rd.published = false OR rd.published IS NULL AND ROW_NUMBER() OVER (PARTITION BY rd.published ORDER BY w.nr ASC) = 1 
        THEN true 
        ELSE false 
    END AS first_unpublished
  FROM weeks w
LEFT JOIN course_data cd ON cd.id = w.course_id
LEFT JOIN result_data rd ON rd.week_id = w.id
LEFT JOIN round_data r ON rd.id = r.result_id
LEFT JOIN winner_data wd ON rd.id = wd.result_id
LEFT JOIN tee_data td ON td.id = w.tee_id
GROUP BY w.id, cd.name, rd.id, r.id, rd.published, wd.id, td.name
ORDER BY w.nr ASC
`

type GetManageResultViewRow struct {
	ID               uuid.UUID   `json:"id"`
	Nr               int32       `json:"nr"`
	IsFinals         pgtype.Bool `json:"isFinals"`
	CourseName       pgtype.Text `json:"courseName"`
	TeeName          pgtype.Text `json:"teeName"`
	ResultID         uuid.UUID   `json:"resultId"`
	Published        bool        `json:"published"`
	Participants     int64       `json:"participants"`
	Winners          int64       `json:"winners"`
	FirstUnpublished bool        `json:"firstUnpublished"`
}

func (q *Queries) GetManageResultView(ctx context.Context) ([]GetManageResultViewRow, error) {
	rows, err := q.db.Query(ctx, getManageResultView)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetManageResultViewRow
	for rows.Next() {
		var i GetManageResultViewRow
		if err := rows.Scan(
			&i.ID,
			&i.Nr,
			&i.IsFinals,
			&i.CourseName,
			&i.TeeName,
			&i.ResultID,
			&i.Published,
			&i.Participants,
			&i.Winners,
			&i.FirstUnpublished,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResultById = `-- name: GetResultById :one
WITH week_data AS (
  SELECT w.id, w.nr, w.course_id, w.tee_id FROM weeks w
), tee_data AS (
  SELECT t.id, t.slope, t.cr FROM tees t
)
SELECT
  r.id,
  td.slope,
  td.cr,
  wd.nr::integer as week_nr,
  wd.course_id::UUID as course_id
FROM results r
LEFT JOIN week_data wd ON wd.id = r.week_id
LEFT JOIN tee_data td ON td.id = wd.tee_id
WHERE r.id = $1
`

type GetResultByIdRow struct {
	ID       uuid.UUID       `json:"id"`
	Slope    pgtype.Int4     `json:"slope"`
	Cr       decimal.Decimal `json:"cr"`
	WeekNr   int32           `json:"weekNr"`
	CourseID uuid.UUID       `json:"courseId"`
}

func (q *Queries) GetResultById(ctx context.Context, id uuid.UUID) (GetResultByIdRow, error) {
	row := q.db.QueryRow(ctx, getResultById, id)
	var i GetResultByIdRow
	err := row.Scan(
		&i.ID,
		&i.Slope,
		&i.Cr,
		&i.WeekNr,
		&i.CourseID,
	)
	return i, err
}

const getRoundsByResultId = `-- name: GetRoundsByResultId :many
WITH player_data AS (
  SELECT p.id, p.first_name, p.last_name, p.hcp FROM players p
)
SELECT 
  r.id, r.net_in, r.net_out, r.gross_in, r.gross_out, r.old_hcp, r.new_hcp, r.player_id, r.result_id, 
  r.net_in + r.net_out AS net_total,
  r.gross_in + r.gross_out AS gross_total,
  p.first_name, 
  p.last_name, 
  p.hcp
FROM rounds r
LEFT JOIN player_data p ON p.id = r.player_id
WHERE r.result_id = $1
ORDER BY net_total ASC
`

type GetRoundsByResultIdRow struct {
	ID         uuid.UUID       `json:"id"`
	NetIn      int32           `json:"netIn"`
	NetOut     int32           `json:"netOut"`
	GrossIn    int32           `json:"grossIn"`
	GrossOut   int32           `json:"grossOut"`
	OldHcp     decimal.Decimal `json:"oldHcp"`
	NewHcp     decimal.Decimal `json:"newHcp"`
	PlayerID   uuid.UUID       `json:"playerId"`
	ResultID   uuid.UUID       `json:"resultId"`
	NetTotal   int32           `json:"netTotal"`
	GrossTotal int32           `json:"grossTotal"`
	FirstName  pgtype.Text     `json:"firstName"`
	LastName   pgtype.Text     `json:"lastName"`
	Hcp        pgtype.Numeric  `json:"hcp"`
}

func (q *Queries) GetRoundsByResultId(ctx context.Context, resultID uuid.UUID) ([]GetRoundsByResultIdRow, error) {
	rows, err := q.db.Query(ctx, getRoundsByResultId, resultID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoundsByResultIdRow
	for rows.Next() {
		var i GetRoundsByResultIdRow
		if err := rows.Scan(
			&i.ID,
			&i.NetIn,
			&i.NetOut,
			&i.GrossIn,
			&i.GrossOut,
			&i.OldHcp,
			&i.NewHcp,
			&i.PlayerID,
			&i.ResultID,
			&i.NetTotal,
			&i.GrossTotal,
			&i.FirstName,
			&i.LastName,
			&i.Hcp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
