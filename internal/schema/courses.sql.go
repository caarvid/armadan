// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: courses.sql

package schema

import (
	"context"

	"github.com/caarvid/armadan/internal/dto"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCourse = `-- name: CreateCourse :one
INSERT INTO courses (name, par) VALUES ($1, $2) RETURNING id, name, par
`

type CreateCourseParams struct {
	Name string `json:"name"`
	Par  int32  `json:"par"`
}

func (q *Queries) CreateCourse(ctx context.Context, arg *CreateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, createCourse, arg.Name, arg.Par)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.Par)
	return i, err
}

type CreateHolesParams struct {
	Nr       int32     `json:"nr"`
	Par      int32     `json:"par"`
	Index    int32     `json:"index"`
	CourseID uuid.UUID `json:"courseId"`
}

type CreateTeesParams struct {
	Name     string         `json:"name"`
	Slope    int32          `json:"slope"`
	Cr       pgtype.Numeric `json:"cr"`
	CourseID uuid.UUID      `json:"courseId"`
}

const deleteCourse = `-- name: DeleteCourse :exec
DELETE FROM courses WHERE id = $1
`

func (q *Queries) DeleteCourse(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCourse, id)
	return err
}

const deleteTee = `-- name: DeleteTee :exec
DELETE FROM tees WHERE id = $1
`

func (q *Queries) DeleteTee(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTee, id)
	return err
}

const getCourse = `-- name: GetCourse :one
WITH hole_data AS (
  SELECT
    c.id,
    c.name,
    c.par,
    COALESCE(jsonb_agg(to_jsonb(h) ORDER BY h.nr ASC) FILTER (WHERE h.course_id IS NOT NULL), '[]') AS holes
  FROM courses c
  LEFT JOIN holes h ON h.course_id = c.id
  GROUP BY c.id, c.name, c.par
), tee_data AS (
  SELECT
    c.id,
    COALESCE(jsonb_agg(to_jsonb(t)) FILTER (WHERE t.course_id IS NOT NULL), '[]') AS tees
  FROM courses c
  LEFT JOIN tees t ON t.course_id = c.id
  GROUP BY c.id, c.name, c.par
)
SELECT hd.id, hd.name, hd.par, hd.holes, td.tees FROM hole_data hd JOIN tee_data td USING (id) WHERE id = $1::UUID
`

type GetCourseRow struct {
	ID    uuid.UUID     `json:"id"`
	Name  string        `json:"name"`
	Par   int32         `json:"par"`
	Holes *dto.HoleList `json:"holes"`
	Tees  *dto.TeeList  `json:"tees"`
}

func (q *Queries) GetCourse(ctx context.Context, dollar_1 uuid.UUID) (GetCourseRow, error) {
	row := q.db.QueryRow(ctx, getCourse, dollar_1)
	var i GetCourseRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Par,
		&i.Holes,
		&i.Tees,
	)
	return i, err
}

const getCourses = `-- name: GetCourses :many
WITH hole_data AS (
  SELECT
    c.id,
    c.name,
    c.par,
    COALESCE(jsonb_agg(to_jsonb(h) ORDER BY h.nr ASC) FILTER (WHERE h.course_id IS NOT NULL), '[]') AS holes
  FROM courses c
  LEFT JOIN holes h ON h.course_id = c.id
  GROUP BY c.id, c.name, c.par
), tee_data AS (
  SELECT
    c.id,
    COALESCE(jsonb_agg(to_jsonb(t)) FILTER (WHERE t.course_id IS NOT NULL), '[]') AS tees
  FROM courses c
  LEFT JOIN tees t ON t.course_id = c.id
  GROUP BY c.id, c.name, c.par
)
SELECT hd.id, hd.name, hd.par, hd.holes, td.tees FROM hole_data hd JOIN tee_data td USING (id)
`

type GetCoursesRow struct {
	ID    uuid.UUID     `json:"id"`
	Name  string        `json:"name"`
	Par   int32         `json:"par"`
	Holes *dto.HoleList `json:"holes"`
	Tees  *dto.TeeList  `json:"tees"`
}

func (q *Queries) GetCourses(ctx context.Context) ([]GetCoursesRow, error) {
	rows, err := q.db.Query(ctx, getCourses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCoursesRow
	for rows.Next() {
		var i GetCoursesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Par,
			&i.Holes,
			&i.Tees,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCourse = `-- name: UpdateCourse :one
UPDATE courses SET name = $1, par = $2 WHERE id = $3 RETURNING id, name, par
`

type UpdateCourseParams struct {
	Name string    `json:"name"`
	Par  int32     `json:"par"`
	ID   uuid.UUID `json:"id"`
}

func (q *Queries) UpdateCourse(ctx context.Context, arg *UpdateCourseParams) (Course, error) {
	row := q.db.QueryRow(ctx, updateCourse, arg.Name, arg.Par, arg.ID)
	var i Course
	err := row.Scan(&i.ID, &i.Name, &i.Par)
	return i, err
}
